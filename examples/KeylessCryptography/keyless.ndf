# KEYLESS ENCRYPTION AND DECRYPTION
#
# These demos demonstrates a keyless cryptographic system described in the paper
# "Keyless encryption and decryption," which can be found at www.cs.uml.edu/~stu.
# The system employs the operations of Gerard Langlet's "parity logic" to encode
# and decode plaintexts.
#
# encrypt implements keyless encryption. The first argument is the string to be 
# encrypted, and the second argument is the algorithm to be used, represented as a
# string.
#
# Example: 
#         m := encrypt 'This is a string.' 'HEL RCOG BVD'
#
# decrypt implements keyless decryption. Argument "m" is the boolean 
# vector to be decoded. The second argument is the algorithm to be used. Using the result
# m from the example above, the correct decryption would be:
#
#        decrypt m 'BVI RCOG RCOG HEL'
# 
# The op "test_tr" below illustrates the end-to-end use of the keyless cryptographic system.



#  FUNDAMENTAL OPS


decimal is INNER [ + , * ] [ 2 power tell tally , reverse ]


binary is op x n { reverse ( 1 match ( ( x quotient ( 2 power tell n ) ) mod 2 ) ) }


lg is op x { ln x / ln 2.0 }


randv is op N P { list random N < P }


str2binvec is op str { content ( each charrep str eachleft binary 8 ) }


binvec2str is op bv { each char ( each decimal rows ( ( floor ( tally bv / 8 ) ) 8 reshape bv ) ) }


rhalf is op S { floor ( tally S / 2 ) takeright S }


lhalf is op S { floor (tally S / 2 ) take S }


PAD is op str { power 2 ( ceiling lg tally str ) take str }



# LANGLET'S PARITY LOGIC


HEL is op S {
   IF tally S = 1 THEN
      S
   ELSE
      HEL lhalf S link HEL ( lhalf S xor rhalf S )
   ENDIF
}


COG is op S {
   IF tally S = 1 THEN
      S
   ELSE
      COG (rhalf S xor lhalf S) link COG rhalf S
   ENDIF
}


RCOG is op S { reverse COG S }


RHEL is op S { reverse HEL S }


BVI is op x { acc_xor x }


BVD is op S { 1 take S link( 1 drop S xor( -1 drop S ) ) }


BSI is op S { reduce or S }



# KEYLESS CRYPTOGRAPHY SYSTEM


# Encrypt a string, str, using algorithm alg represented as a string
		
encrypt is op str alg {
   bin := str2binvec str ;
   bin := pad bin ;
   execute ( alg link ' ' link picture bin )
}


# decrypt a bitstring, code, using algorithm alg represented as a string

decrypt is op code alg {
   bin := execute ( alg link ' ' link picture code ) ;
   binvec2str bin
}


# Create a random encryption algorithm

build_alg is op n {
   funcs := 'HEL ' 'COG ' 'RHEL ' 'RCOG ' 'BVI ' 'BVD ' ;
   i := floor ( 6 * random n ) ;
   funcs#i
}


# Create the decryption algorithm for the above algorithm

build_dec is op alg {
   res := null ;
   FOR i WITH tell tally alg DO
      fn := alg@i ;
      CASE fn FROM
        'HEL ': res := res append 'HEL ' ; END        
        'COG ': res := res append 'COG ' ; END        
        'RHEL ': res := res link 'RHEL ' 'RHEL ' ; END
        'RCOG ': res := res link 'RCOG ' 'RCOG ' ; END
        'BVI ': res := res append 'BVD ' ; END
        'BVD ': res := res append 'BVI ' ; END
      ELSE
        'Bad function' ;
      ENDCASE ;
   ENDFOR ;
   res := reverse res ;
   res
}


# Test an encryption algorithm for do-nothing combinations and remove them.
# Argument "alg" must be in the format produced by build_alg.
#
# Example: test_alg build_alg 16

all is op str1 str2 { 
   IF ( tally str1 ) = ( tally str2 ) THEN
      res := reduce and ( str1 match str2 )
   ELSE
      res := o
   ENDIF ;
   res
}


test_alg is op alg {
   n := tally  alg ;
   write alg ;
   IF depth alg = 2 THEN
      preprev := null ;
      prev := alg@0 ;
      res := prev ;
      FOR i WITH count ( n - 1 ) DO
         curr := alg@i ;
         IF ( all curr 'HEL ' ) and ( all prev 'HEL ' ) THEN
            write 'HEL HEL pair' ;
         ELSEIF ( all curr 'COG ' ) and ( all prev 'COG ' ) THEN
            write 'COG COG pair' ;
         ELSEIF ( all prev 'RHEL ' ) and ( all curr 'RCOG ' ) THEN
            write 'RHEL RCOG pair' ;
         ELSEIF ( all prev 'RCOG ' ) and ( all curr 'RHEL ' ) THEN
            write 'RCOG RHEL pair' ;
         ELSEIF ( all prev 'BVI ' ) and ( all curr 'BVD ' ) THEN
            write 'BVI BVD pair' ;
         ELSEIF ( all prev 'BVD ' ) and ( all curr 'BVI ' ) THEN
            write 'BVD BVI pair' ;
         ELSEIF ( all preprev 'RHEL ' ) and ( all prev 'RHEL ' ) and ( all curr 'RHEL ' ) THEN
             write 'RHEL triple' ;
         ELSEIF ( all preprev 'RCOG ' ) and ( all prev 'RCOG ' ) and ( all curr 'RCOG ' ) THEN
             write 'RCOG triple' ;
         ELSE
            res := res link curr ;
         ENDIF ;
         preprev := prev ;
         prev := curr ;
      ENDFOR ;
   ELSE
      res := alg ;
   ENDIF ;
   p := 1 dropright res ;
   nops := tally (`  match p cut p ) ;
   write ( 'Actual algorithm length: ' link picture nops ) ;
   ( ` match res cut res ) eachleft link ' ' 
}


Fileout is op Fname ciphertext { writefield Fname 0 ciphertext }


Filein is op Fname { readfield Fname 0 ( filelength Fname ) }


# Encrypt a plaintext string and save it as a text file.
#    alg = encrypting algorithm in build_alg format

transmit is op message alg Filename {
   m := encrypt message ( content alg ) ;
   nrows := ceiling ( tally m / 7 ) ;
   m := 7 * nrows take m ;
   dims := nrows 7 ;
   mat := dims reshape m ;
   mat := byrows o link mat ;
   ints := raw_bytes ( byrows decimal mat + 31 ) ;
   bytes := nrows 8 reshape ints ;
   x := bytes|[,0] ;
   Fileout Filename x ;
}


# Convert an excrypted text file into the plaintext.
#   dec = decrypting algorithm in build_alg format

receive is op dec Filename {
   m := Filein Filename ;
   ints := each byterep m - 31 ;
   bytes := ints eachleft binary 8 ;
   bits := content ( 1 eachright drop bytes ) ;
   x := ( floor ( shape bits / 8 ) * 8 ) take bits ;
   decrypt x ( content dec )
}


# Write an encrypting/decrypting algorithm to a text file.

write_alg is op alg Filename {
   alg := content alg ;
   Fd := open Filename "w ;
   writefile Fd 'empty' ;
   close Fd ;
   Fileout Filename alg
}


# Read an encrypting/decrypting algorithm from a text file.

read_alg is op Filename {
   alg := Filein Filename ;
   alg := ` match alg cut alg ;
   alg eachleft link ' '
}


# TESTS

# Test the keyless system end-to-end
#    message  = test string
#    n        = number of ops requested in the encrypting algorithm
#    Filename = name of the text file to be communicated

test_TR is op message n Filename {
   alg := build_alg n ;
   alg := test_alg alg ;
   dec := build_dec alg ;
   write_alg dec "decrypt.txt ;
   dec := read_alg "decrypt.txt ;
   Fd := open Filename "w ;
   writefile Fd 'empty' ;
   close Fd ;
   x := transmit message alg Filename ;
   y := receive dec Filename ;
   y
}


# Test the inverse relationship between encrypting and decrypting algorithms
#    k = desired length of algorithms, in operations
#    n = number of trials

test_inverse is op n k {
   alphanum := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ;
   FOR i WITH tell n DO
      alg := build_alg k ;
      alg := test_alg alg ;
      dec := build_dec alg ;
      m1 := encrypt alphanum ( content alg ) ;
      m2 := encrypt alphanum ( content dec ) ;
      p1 := decrypt m1 ( content dec ) ;
      p2 := decrypt m2 ( content alg ) ;
      IF not ( all p1 p2 ) THEN
         write "FAIL ;
      ENDIF ;
   ENDFOR ;
}


# Test the correctness of encryption and decryption
#    k = desired length of random algorithms, in operations
#    n = number of trials iterations
#
# test_code will report any failure of decryption to recover the plaintext exactly.
#
# Example: test_code 1000 10  <- Test 1000 random 10-op algorithms.

test_code is op n k {
   alphanum := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ;
   FOR i WITH tell n DO
      IF ( i mod 100 = 0 ) THEN
         write i ;
      ENDIF ;
      alg := build_alg k ;
      dec := build_dec alg ;
      alg := 1 dropright content alg ;
      dec := 1 dropright content dec ;
      m := encrypt alphanum alg ;
      z := 62 take ( decrypt m dec ) ;
      IF not ( reduce and ( z match alphanum ) ) THEN
         write 'bad:' ;
         write alg ;
         write dec ;
      ENDIF ;
   ENDFOR ;
}


# Determine average execution time for each of the six ops used for keyless encryption
# and decryption: HEL, COG, RHEL, RCOG, BVI, and BVD. In addition, REV can be entered
# to determine the average execution time for reversing a vector. The n argument is the
# length in bits of the string to be encrypted. The string will be padded if necessary
# so that its length is a power of 2.
#
# Example: encrypt_times 'HEL' 1000000

encrypt_times is op fn n {
   str := randv n 0.5 ;
   str := PAD str ;
   CASE fn FROM
     'HEL': t1 := time ;        
        FOR i WITH tell 12 DO
           x := HEL str ;
        ENDFOR ;
        t2 := time ;
        avg := t2 - t1 / 12 ;
        write 'Mean encryption time: ' avg ; END
     'COG': t1 := time ;        
        FOR i WITH tell 12 DO
           x := COG str ;
        ENDFOR ;
        t2 := time ;
        avg := t2 - t1 / 12 ;
        write 'Mean encryption time: ' avg ; END
    'RHEL': t1 := time ;        
        FOR i WITH tell 12 DO
           x := RHEL str ;
        ENDFOR ;
        t2 := time ;
        avg := t2 - t1 / 12 ;
        write 'Mean encryption time: ' avg ; END
    'RCOG': t1 := time ;        
        FOR i WITH tell 12 DO
           x := RCOG str ;
        ENDFOR ;
        t2 := time ;
        avg := t2 - t1 / 12 ;
        write 'Mean encryption time: ' avg ; END
    'BVI': t1 := time ;        
        FOR i WITH tell 12 DO
           x := BVI str ;
        ENDFOR ;
        t2 := time ;
        avg := t2 - t1 / 12 ;
        write 'Mean encryption time: ' avg ; END
    'BVD': t1 := time ;        
        FOR i WITH tell 12 DO
           x := BVD str ;
        ENDFOR ;
        t2 := time ;
        avg := t2 - t1 / 12 ;
        write 'Mean encryption time: ' avg ; END
    'REV': t1 := time ;        
        FOR i WITH tell 12 DO
           x := reverse str ;
        ENDFOR ;
        t2 := time ;
        avg := t2 - t1 / 12 ;
        write 'Mean reversal time: ' avg ; END
    'BSI': t1 := time ;        
        FOR i WITH tell 12 DO
           x := BSI str ;
        ENDFOR ;
        t2 := time ;
        avg := t2 - t1 / 12 ;
        write 'Mean BSI time: ' avg ; END
   ELSE
      'Bad function' ;
   ENDCASE ;
}

