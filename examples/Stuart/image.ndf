# BINARY IMAGE PROCESSING
#
# This file provides Nial ops for processing binary images.  The "bw" ops require
# binary images that are square and have sides whose length is a power of 2. The
# op "bwprep" below can be used to modify a binary image so that it meets these
# requirements.


loaddefs "display


# FUNDAMENTAL OPERATIONS


# Base-2 logarithm

lg is op x { ln x / ln 2.0 }


# Convert a string of numeric characters to the corresponding integer.

str2num is op n { sum ( reverse( 10 power tell tally n ) * ( n eachleft find '0123456789' ) ) }



# SHIFTS, ROTATIONS, AND REFLECTIONS


# Shift matrix m one position North

shiftN is op m {
   x := [ 1 , second shape m ] reshape o ;
   0 catenate [ [ 1 , 0 ] drop m , x ]
}


# Shift matrix m one position East

shiftE is op m {
   x := [ first shape m , 1 ] reshape o ;
   1 catenate [ x , [ 0 , -1 ] drop m ]
}


# Shift matrix m one position West

shiftW is op m {
   x := [ first shape m , 1 ] reshape o ;
   1 catenate [ [ 0 , 1 ] drop m , x ]
}


# Shift matrix m one position South

shiftS is op m {
   x := [ 1 , second shape m ] reshape o ;
   0 catenate [ x , [ -1 , 0 ] drop m ]
}


# Shift matrix m one position Northeast

shiftNE is op m { shiftN shiftE m }


# Shift matrix m one position Northwest

shiftNW is op m { shiftN shiftW m }


# Shift matrix m one position Southeast

shiftSE is op m { shiftS shiftE m }


# Shift matrix m one position Southwest

shiftSW is op m { shiftS shiftW m }


# Rotate matrix n positions down

rotd is op m n {
   t gets opp n ;
   bycols t rotate m
}


# Rotate matrix n positions right

rotr is op m n {
   t gets opp n ;
   byrows t rotate m
}


# Rotate matrix n positions up

rotu is op m n { bycols n rotate m }


# Rotate matrix n positions left

rotl is op m n { byrows n rotate m }


# Reflect a matrix around its vertical axis

revv is op x {
   byrows reverse x }


# Reflect a matrix around its horizontal axis

revh is op x {
   bycols reverse x }


# Reflect a matrix around its main antidiagonal

revd is op x { revh revv x }

  

# DETECT SELF AND NEIGHBORHOOD


bdetect is op x { x + shiftNW x + shiftN x + shiftNE x + shiftW x + shiftE x + shiftSW x + shiftS x + shiftSE x }



# DILATE AND ERODE

# NB: The "bw" functions is this section require square matrix arguments. The bwprep function below
crops an image to the smallest enclosing bounding box and then pads it out to the smallest enclosing
square.


bwdilate is op x { bdetect x >= 1 }

bwerode is op x { not( bdetect x < 9 ) }



# IMAGE PROCESSING OPERATIONS BUILT ON DILATE AND ERODE


bwclose is op x { bwerode bwdilate x }

bwopen is op x { bwdilate bwerode x }

bwperim is op x { x xor bwerode x } 

bwclean is op x {
   y := x ;
   y#( bdetect x match l sublist grid y ) := o ; 
   y
}



# PREPARE IMAGES FOR PROCESSING


rot90 is op x { byrows reverse transpose x }


range is op b e {
   b + tell ( e - b + 1 )
}


crop is op m {
   FOR i WITH tell 4 do
      r c := shape m ;
      row := m|[0,] ;
      WHILE not REDUCE or row DO
         m := m|[range 1 (r - 1) , ] ;
         r c := shape m ;
         row := m|[0,] ;
      ENDWHILE ;
      m := rot90 m ;
   ENDFOR ;
   m
}


pad is op m {
   r c := shape m ;
   IF r > c THEN
      side := power 2 ( ceiling lg r ) ;
   ELSE
      side := power 2 ( ceiling lg c ) ;
   ENDIF ;
   bgr := side side reshape l ;
   bgr|[tell r , tell c] := m ;
   bgr
}


bwprep is op m { pad crop m }



# IMAGE PROCESSING OPERATIONS


# median filter to clean up bitmap images
#
# This op is fairly slow. A better choice is to use the median filter op in
# irfanview.ndf. This requires IrfanView to be installed on your system.

stencil is op dimx dims {
   x:=dimx reshape o ;
   x|[tell first dims,tell second dims]:=l ;
   x
}


median is op x {
   dimx:=shape x ;
   dims:=3 3 ;
   sten:=stencil dimx dims ;
   R:=1+tell (first dimx - 2) ;
   C:=1+tell (second dimx - 2) ;
   z:=x ;
   FOR i WITH R DO
      temp:=sten ;
      FOR j WITH C DO
         pat:=sortup(temp sublist x) ;
         z@[i,j]:=pat@4 ;
         temp:=rotr temp 1 ;
      ENDFOR ;
      sten:=rotd sten 1 ;
   ENDFOR ;
   z
}


# Shrink - performs n iterations of Levialdi's shrinking operation on bitmap Im

shrink is op Im n {
   for i with tell n do
      next := Im and ( shiftS Im or shiftS shiftE Im or shiftE Im ) ;
      next := next or ( shiftE Im and shiftS Im and not Im ) ;
      Im := next ;
   endfor ;
   next
}


# Count of connected components in bitmap Im

cc_count is op Im {
   k := 0 ;
   repeat
      next := Im and ( shiftS Im or shiftS shiftE Im or shiftE Im ) ;
      next := next or ( shiftE Im and shiftS Im and not Im ) ;
      conn := shiftW Im or shiftN shiftW Im or shiftN Im or ( Im and shiftN shiftE Im ) or ( Im and shiftS shiftW Im ) ;
      conn := Im and not next and not conn ;
      Im := next ;
      smore := or Im ;
      k := k + sum conn ;
   until not smore endrepeat ;
   k
}


# Connected components

assign_colors is op B {
   nrows ncols := shape B ;
   B := abs B ;
   Res := nrows ncols reshape 0 ;
   numlabel := 1 ;
   equiv := null ;
   FOR c WITH range 1 ( ncols - 1 ) DO
      FOR r WITH range 1 ( nrows - 1 ) DO
         IF B@[ r , c ] = 0 THEN
            Res@[ r , c ] := 0 ;
         ELSEIF Res@[ r - 1 , c ] = 0 and ( Res@[ r , c - 1 ] = 0 ) THEN
            Res@[ r , c ] := numlabel ;
            numlabel := numlabel + 1 ;
         ELSEIF Res@[ r - 1 , c ] ~= 0 and ( Res@[ r , c - 1 ] = 0 ) THEN
            Res@[ r , c ] := Res@[ r - 1 , c ] ;
         ELSEIF Res@[ r , c - 1 ] ~= 0 and ( Res@[ r - 1 , c ] = 0 ) THEN
            Res@[ r , c ] := Res@[ r , c - 1 ] ;
         ELSEIF Res@[ r , c - 1 ] = Res@[ r - 1 , c ] THEN
            Res@[ r , c ] := Res@[ r , c - 1 ] ;
         ELSEIF Res@[ r , c - 1 ] ~= Res@[ r - 1 , c ] THEN
            Res@[ r , c ] := Res@[ r , c - 1 ] ;
            equiv := equiv link solitary [ Res@[ r , c - 1 ] , Res@[ r - 1 , c ] ] ;
         ELSE
            write 'Should never get here' ;
         ENDIF ;
      ENDFOR ;
   ENDFOR ;
   equiv := sortup cull equiv ;
   Res pair equiv
}


merge is op equiv {
   eqclasses := null ;
   n := tally equiv ;
   grn := tell n ;
   used := n reshape o ;
   FOR i WITH tell n DO
      IF not reduce and used THEN
         head := first ( not used sublist grn ) ;
         class := equiv@head ;
         FOR j WITH tell n DO
            IF ( not used@j ) and reduce or ( equiv@j eachleft in class ) THEN
               class := class link equiv@j ;
               used@j := l ;
            ENDIF ;
         ENDFOR ;
         eqclasses := eqclasses link solitary class ;
      ENDIF ;
   ENDFOR ;
   each sortup each cull eqclasses
}


adjust_colors is op Res groups {
   n := tally groups ;
   IF n > 1 THEN
      GR := grid Res ;
      FOR i WITH tell n DO
         class := content ( 1 take groups ) ;
         color := class@0 ;
         FOR j WITH tell tally class DO
            Res#( Res match class@j sublist GR ) := color ;
         ENDFOR ; 
         groups := 1 drop groups ;  
      ENDFOR ;
   ENDIF ;
   Res
}


adjust_solitary is op Res groups {
   group := content groups ;
   color := group@0 ;
   gr := grid Res ;
   FOR i WITH range 1 ( tally group - 1 ) DO
      Res#(Res match group@i sublist gr ) := color ;
   ENDFOR ;
   Res
}


final_colors is op Res {
   colors := sortup cull Res ;
   GR := grid Res ;
   FOR i WITH tell tally colors DO
      Res#( Res match colors@i sublist GR ) := i ;
   ENDFOR ;
   Res
}


ConCom is op B {
   lpad := [ first shape B , 1 ] reshape o ;
   tpad := [1 , 1 + second shape B ] reshape o ;
   B := 1 catenate lpad B ;
   B := 0 catenate tpad B ; 
   Res equiv := assign_colors B ;
   groups := sortup merge merge equiv ;
   IF tally groups = 1 THEN
      Res := adjust_solitary Res groups ;
   ELSE
      Res := adjust_colors Res groups ;
   ENDIF ;
   Res := final_colors Res ;
   Res
}


# Make n-by-n test image containing approximately k objects.

cctest is op n k {
   m := n n reshape o ;
   s := floor ( n / 4 ) ;
   obj := s s reshape l ;
   FOR i WITH tell k DO
      m|[ tell s , tell s ] := obj ;
      r c := floor ( 0.75 * n * random 2 ) ;
      m := rotd ( rotr m c ) r ;
   ENDFOR ;
   m
}


# Region of interest, given the coordinates of the upper left and lower right corners

roi is op m ul lr {
   size:=lr - ul + 1 ;
   m|[(first ul + tell first size),(second ul + tell second size)]
}


# Perform a sort of "uniform convolution" on matrix m. s is the length of the side of the 
# box to be used.

uniconv is op m s {
   m := abs m ;
   half := s * s / 2 ;
   t := m ;
   right := rotr m 1 ;
   for i with count ( s - 1 ) do
      t := t + right ;
      right := rotr right 1 ;
   endfor ;
   down := rotd t 1 ;
   for i with count ( s - 1 ) do
      t := t + down ;
      down := rotd down 1 ;
   endfor ;
   t > half
}


# Center of mass of binary image m (assumes figure = l's, background = o's)

cm is op m {
   k := m sublist grid m ;
   i := sum each first k quotient tally k ;
   j := sum each second k quotient tally k ;
   [ i , j ]
} 



# RANDOM BOOLEAN VECTORS AND MATRICES


# length-N random boolean vector, with the number of 1's approximately P*N

randv is op N P { list random N < P }


# RxC random boolean matrix, with the number of 1's approximately P*R*C

randm is op R C P { [ R , C ] reshape ( R * C randv P ) }
