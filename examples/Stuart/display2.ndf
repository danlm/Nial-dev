# DISPLAY OPS


# Make a "plain" .pbm file from a boolean matrix. Include the .pbm extension in the file name.

writepbm is op Bitmap Filename {
   header := 'P1' ;
   dims := picture reverse shape Bitmap ;
   LF := char 10 ;
   bits := content picture content abs Bitmap ;
   outbits := '' ;
   WHILE tally bits >= 64 DO
      outbits := outbits link ( 64 take bits ) link LF ;
      bits := 64 drop bits ;
   ENDWHILE ;
   IF tally bits > 0 THEN
      outbits := outbits link bits link LF ;
   ENDIF ;
   Fd := open Filename "w ;
   writefile Fd ( header link LF link dims link LF link outbits ) ;
   close Fd ;
}


# Read a "plain" .pbm file into a boolean matrix (bitmap). Include the .pbm extension in the file name.

Filein is op Fname { readfield Fname 0 ( filelength Fname ) }

str2num is op n { sum( reverse( 10 power tell tally n ) * ( n eachleft find '0123456789' ) ) }

readpbm is op Filename {
   str := Filein Filename ;
   fields := ( char 10 ) match str cut str ;
   fields := 1 drop fields ;
   IF first fields@0 match char 35 THEN
      fields := 1 drop fields ;
   ENDIF ;
   dims := content fields@0 ;
   c := char 32 find dims ;
   ncols := str2num ( c take dims ) ;
   dims := c + 1 drop dims ;
   r := char 10 find dims ;
   nrows := str2num ( r take dims ) ;
   fields := 1 drop fields ;
   pixels := content fields ;
   pixels := not ( pixels match char 32 ) sublist pixels ;
   ( nrows ncols reshape pixels ) eachleft match `0
}


# Write a "plain" .pgm file from a real or integer matrix. Include the .pgm extension in the file name.

writepgm is op x file {
   shx := reverse shape x ;
   y := x - min x ;
   y := floor( y / max y * 255 ) ;
   Fd := open file "w ;
   writefile Fd 'P2' ;
   writefile Fd ( picture shx ) ;
   writefile Fd '255' ;
   writefile Fd ( picture y ) ;
   close Fd ;
}


# Read a "plain" .pgm file into an integer matrix. Include the .pgm extension in the file name.

readpgm is op Filename {
   str := Filein Filename ;
   fields := ( char 10 ) match str cut str ;
   fields := 1 drop fields ;
   IF first fields@0 match char 35 THEN
      fields := 1 drop fields ;
   ENDIF ;
   dims := content fields@0 ;
   c := char 32 find dims ;
   ncols := str2num ( c take dims ) ;
   dims := c + 1 drop dims ;
   r := char 10 find dims ;
   nrows := str2num ( r take dims ) ;
   fields := 1 drop fields ;
   maxp := str2num fields@0 ;
   fields := 1 drop fields ;
   cfields := content fields ;
   cfields := char 32 match cfields cut cfields ;
   cfields := each str2num cfields ;
   nrows ncols reshape cfields
}


# Make a portable pixmap hot-iron color scale image file from a real or integer matrix. Include the .ppm extension in the file name.

hotiron is op x file {
   shx := reverse shape x ;
   y := content( x - min x ) ;
   y := y / max y ;
   r := y ;
   g := y ;
   b := y ;
   FOR i WITH tell tally y DO
      IF y@i <= 0.33 THEN
         r@i := floor( y@i / 0.33 * 255 ) ;
         g@i := 0 ;
         b@i := 0 ;
      ELSEIF  ( y@i > 0.33 ) and ( y@i < 0.67 ) THEN
         r@i := 255 ;
         g@i := floor( y@i - 0.33 / 0.33 * 255 ) ;
         b@i := 0 ;
      ELSE
         r@i := 255 ;
         g@i := 255 ;
         b@i := floor( y@i - 0.67 / 0.33 * 255 ) ;
      ENDIF ;
   ENDFOR ;
   z := transpose( [ 3 , tally y ] reshape ( r link g link b ) ) ;
   Fd := open file "w ;
   writefile Fd 'P3' ;
   writefile Fd ( picture shx ) ;
   writefile Fd '255' ;
   writefile Fd ( picture z ) ;
   close Fd ;
}


# Make a pseudocolor portable pixmap image file from an integer matrix. Include the .ppm extension in the file name.
# This routine supports up to 14 connected components (i.e., 14 colors including black). The color table can be
# expanded with more RBG triples to allow a larger number of connected components.

pseudocolor is op x file {
   colors := 14 3 reshape 0 ;
   colors|[0,] := 0 0 0 ;
   colors|[1,] := 0 0 255 ;
   colors|[2,] := 0 255 0 ;
   colors|[3,] := 0 255 255 ;
   colors|[4,] := 255 0 0 ;
   colors|[5,] := 255 0 255 ;
   colors|[6,] := 255 255 0 ;
   colors|[7,] := 255 255 255 ;
   colors|[8,] := 138 93 226 ;
   colors|[9,] := 50 205 50 ;
   colors|[10,] := 233 150 122 ;
   colors|[11,] := 255 20 147 ;
   colors|[12,] := 160 32 240 ;
   colors|[13,] := 9 249 17 ;
   shx := reverse shape x ;
   r := shx@0 ;
   c := shx@1 ;
   z := null ;
   FOR i WITH tell r DO
      FOR j WITH tell c DO
         color := x@[ i , j ] ;
         z := z link colors|[ color , ] ;
      ENDFOR ;      
   ENDFOR ;
   z := [ tally x , 3 ] reshape z ;
   Fd := open file "w ;
   writefile Fd 'P3' ;
   writefile Fd ( picture shx ) ;
   writefile Fd '255' ;
   writefile Fd ( picture z ) ;
   close Fd ;
}



# DISPLAY OPS USING IrfanView

# All file names are single-quoted strings. Include the full path for any files
# not in the same directory as IrfanView.


# Display bitmap "mat" using IrfanView

disp_bits is op mat {
   writepbm mat "_temp.pbm ;
   host '"C:\Program Files (x86)\IrfanView\i_view32.exe" _temp.pbm' ;
   host '"del" _temp.pbm' ;
}


# Display grayscale "mat" using IrfanView

disp_gray is op mat {
   writepgm mat "_temp.pgm ;
   host '"C:\Program Files (x86)\IrfanView\i_view32.exe" _temp.pgm' ;
   host '"del" _temp.pgm' ;
}


# Convert an image file to a different format using IrfanView

convert is op infile outfile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /convert=' ;
   host ( command link ' ' link infile link switch link outfile ) ; 
}


# Apply a median filter to an image file

median_filter is op infile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /effect=(6,3,0)' ;
   host ( command link ' ' link infile link switch ) ; 
}


# Apply edge detection to an image file

edge_detect is op infile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /effect=(5,3,0)' ;
   host ( command link ' ' link infile link switch ) ; 
}


# Resize an image file: width and height are the desired new dimensions in pixels.

resize is op infile width height {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /resize=(' link ( picture height ) link ',' link ( picture width ) link ')' ;
   host ( command link ' ' link infile link switch ) ; 
}


# Convert input image to grayscale

img2gray is op infile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /gray' ;
   host ( command link ' ' link infile link switch ) ; 
}


# Rotate input image to right

rotate_r is op infile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /rotate_r' ;
   host ( command link ' ' link infile link switch ) ; 
}


# Rotate input image to left

rotate_l is op infile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /rotate_l' ;
   host ( command link ' ' link infile link switch ) ; 
}


# Horizontal flip

hflip is op infile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /hflip' ;
   host ( command link ' ' link infile link switch ) ; 
}


# Vertical flip

vflip is op infile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /vflip' ;
   host ( command link ' ' link infile link switch ) ; 
}


# Invert an image (negative)

invert is op infile {
   command := '"C:\Program Files (x86)\IrfanView\i_view32.exe "' ;
   switch := ' /invert' ;
   host ( command link ' ' link infile link switch ) ; 
}








