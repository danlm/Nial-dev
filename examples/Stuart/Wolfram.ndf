# WOLFRAMS'S SIMPLE CELLULAR AUTOMATON
#
# This demonstration implements Stephen Wolfram's simple cellular automaton in Nial.
# The demo op can produce images of the evolution of the automaton using all
# 256 rules.
#
# The demo op shows 256 steps of the evolution of the cellular automaton with a selected
# rule. The rule may be any integer 0-255. Some of the more interesting rules are:
# 18 22 26 30 45 60 73 75 82 86 89 90 101 102 105 110 124 126 129 135 137 146 149 150
# 153 154 161 165 167 169 181 182 193 195 210 218 225. The image will be immediately
# displayed by IrfanView, which will retain control until it is closed.
#
# Examples:
#
#         demo 110
#
# will generate 256 steps of rule 110, which has been proven to be Turing universal.
#
#         demo 30
#
# will generate 256 steps of rule 30, which was the crucial experiment that led to the
# publication of "A New Kind of Science." Rule 30 is also the basis of Mathematica's
# random number generator.
#
# For the theory and applications of the simple cellular automaton, see:
# Stephen Wolfram. A New Kind of Science. Champaign, IL: Wolfram Media (2002)


loaddefs "display


# Decimal-to-binary conversion

binary is op x n { reverse ( 1 match ( ( x quotient ( 2 power tell n ) ) mod 2 ) ) }


#  Wolfram's routine for generating the next state of a cellular automaton

CAStep is op b_rule x {
   a := abs x ;
   i := 7 - ( 1 rotate a + ( 2 * ( a + ( 2 * ( -1 rotate a ) ) ) ) ) ;
   b_rule#i match l
}


# Compute successive states for cellular automaton with rule and initial
  conditions x. Stop when wraparound would occur.

CA is op x rule {
   n := floor ( tally x / 2 ) ;
   b_rule := binary rule 8 ;
   len := tally x ;
   res := x ;
   for i with tell n do
      x := CAStep b_rule x ;
      res := res link x ;
   endfor ;
   [ n+1 , len ] reshape res
}


# Create Wolfram's length n standard initial conditions for the cellular automaton

stdinit is op n { ( floor( n / 2 ) reshape o ) link l link ( floor( n / 2 ) reshape o ) }


# Remove completely blank right or left side from CA image

compress is op Im {
   nrows ncols := shape Im ;
   p := nrows ncols reshape ( bycols sum abs Im > 0 ) ;
   nrows ( floor ( sum p / nrows ) ) reshape ( p sublist Im )
}


demo is op rule {
   pic := compress ca (stdinit 512) rule ;
   disp_bits pic ;
}
